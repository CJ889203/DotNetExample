// Decompiled with JetBrains decompiler
// Type: System.Text.RegularExpressions.RegexRunner
// Assembly: System.Text.RegularExpressions, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// MVID: 9E234CFB-607D-4CAE-9C21-1A71C799D034
// Assembly location: C:\Program Files\dotnet\shared\Microsoft.NETCore.App\6.0.9\System.Text.RegularExpressions.dll
// XML documentation location: C:\Program Files\dotnet\packs\Microsoft.NETCore.App.Ref\6.0.9\ref\net6.0\System.Text.RegularExpressions.xml


#nullable enable
namespace System.Text.RegularExpressions
{
  /// <summary>The <see cref="T:System.Text.RegularExpressions.RegexRunner" /> class is the base class for compiled regular expressions.</summary>
  public abstract class RegexRunner
  {
    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected internal int runtextbeg;
    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected internal int runtextend;
    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected internal int runtextstart;
    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected internal string? runtext;
    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected internal int runtextpos;
    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected internal int[]? runtrack;
    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected internal int runtrackpos;
    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected internal int[]? runstack;
    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected internal int runstackpos;
    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected internal int[]? runcrawl;
    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected internal int runcrawlpos;
    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected internal int runtrackcount;
    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected internal Match? runmatch;
    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected internal Regex? runregex;
    private int _timeout;
    private bool _ignoreTimeout;
    private int _timeoutOccursAt;
    private const int TimeoutCheckFrequency = 1000;
    private int _timeoutChecksToSkip;

    /// <summary>Initializes a new instance of the <see cref="T:System.Text.RegularExpressions.RegexRunner" /> class.</summary>
    protected internal RegexRunner()
    {
    }

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    /// <param name="regex">An instance of the regular expression engine.</param>
    /// <param name="text">The text to scan for a pattern match.</param>
    /// <param name="textbeg">The zero-based starting position in <paramref name="text" /> at which the regular expression engine scans for a match.</param>
    /// <param name="textend">The zero-based ending position in <paramref name="text" /> at which the regular expression engine scans for a match.</param>
    /// <param name="textstart">The zero-based starting position to scan for this match.</param>
    /// <param name="prevlen">The number of characters in the previous match.</param>
    /// <param name="quick">
    /// <see langword="true" /> to search for a match in quick mode; otherwise, <see langword="false" />.</param>
    /// <returns>A match.</returns>
    protected internal Match? Scan(
      Regex regex,
      string text,
      int textbeg,
      int textend,
      int textstart,
      int prevlen,
      bool quick)
    {
      return this.Scan(regex, text, textbeg, textend, textstart, prevlen, quick, regex.MatchTimeout);
    }

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    /// <param name="regex">An instance of the regular expression engine.</param>
    /// <param name="text">The text to scan for a pattern match.</param>
    /// <param name="textbeg">The zero-based starting position in <paramref name="text" /> at which the regular expression engine scans for a match.</param>
    /// <param name="textend">The zero-based ending position in <paramref name="text" /> at which the regular expression engine scans for a match.</param>
    /// <param name="textstart">The zero-based starting position to scan for this match.</param>
    /// <param name="prevlen">The number of characters in the previous match.</param>
    /// <param name="quick">
    /// <see langword="true" /> to search for a match in quick mode; otherwise, <see langword="false" />.</param>
    /// <param name="timeout">The timeout interval.</param>
    /// <returns>A match.</returns>
    protected internal Match? Scan(
      Regex regex,
      string text,
      int textbeg,
      int textend,
      int textstart,
      int prevlen,
      bool quick,
      TimeSpan timeout)
    {
      this._timeout = -1;
      bool flag1 = this._ignoreTimeout = Regex.InfiniteMatchTimeout == timeout;
      if (!flag1)
      {
        Regex.ValidateMatchTimeout(timeout);
        this._timeout = (int) (timeout.TotalMilliseconds + 0.5);
        this._timeoutOccursAt = Environment.TickCount + this._timeout;
        this._timeoutChecksToSkip = 1000;
      }
      int num1 = 1;
      int num2 = textend;
      if (regex.RightToLeft)
      {
        num1 = -1;
        num2 = textbeg;
      }
      this.runtextpos = textstart;
      if (prevlen == 0)
      {
        if (textstart == num2)
          return Match.Empty;
        this.runtextpos += num1;
      }
      this.runregex = regex;
      this.runtext = text;
      this.runtextstart = textstart;
      this.runtextbeg = textbeg;
      this.runtextend = textend;
      bool flag2 = false;
      Match runmatch;
      while (true)
      {
        if (this.FindFirstChar())
        {
          if (!flag1)
            this.DoCheckTimeout();
          if (!flag2)
          {
            this.InitializeForGo();
            flag2 = true;
          }
          this.Go();
          runmatch = this.runmatch;
          if (runmatch._matchcount[0] <= 0)
          {
            this.runtrackpos = this.runtrack.Length;
            this.runstackpos = this.runstack.Length;
            this.runcrawlpos = this.runcrawl.Length;
          }
          else
            break;
        }
        if (this.runtextpos != num2)
          this.runtextpos += num1;
        else
          goto label_20;
      }
      this.runtext = (string) null;
      if (quick)
      {
        this.runmatch.Text = (string) null;
        return (Match) null;
      }
      this.runmatch = (Match) null;
      runmatch.Tidy(this.runtextpos);
      return runmatch;
label_20:
      this.runtext = (string) null;
      if (this.runmatch != null)
        this.runmatch.Text = (string) null;
      return Match.Empty;
    }


    #nullable disable
    internal void Scan<TState>(
      Regex regex,
      string text,
      int textstart,
      ref TState state,
      MatchCallback<TState> callback,
      bool reuseMatchObject,
      TimeSpan timeout)
    {
      this._timeout = -1;
      bool flag1 = this._ignoreTimeout = Regex.InfiniteMatchTimeout == timeout;
      if (!flag1)
      {
        this._timeout = (int) (timeout.TotalMilliseconds + 0.5);
        this._timeoutOccursAt = Environment.TickCount + this._timeout;
        this._timeoutChecksToSkip = 1000;
      }
      int num1 = 1;
      int num2 = text.Length;
      if (regex.RightToLeft)
      {
        num1 = -1;
        num2 = 0;
      }
      this.runregex = regex;
      this.runtextstart = this.runtextpos = textstart;
      this.runtext = text;
      this.runtextend = text.Length;
      this.runtextbeg = 0;
      bool flag2 = false;
      while (true)
      {
        while (this.FindFirstChar())
        {
          if (!flag1)
            this.DoCheckTimeout();
          if (!flag2)
          {
            this.InitializeForGo();
            flag2 = true;
          }
          this.Go();
          Match runmatch = this.runmatch;
          if (runmatch._matchcount[0] > 0)
          {
            if (!reuseMatchObject)
              this.runmatch = (Match) null;
            runmatch.Tidy(this.runtextpos);
            flag2 = false;
            if (!callback(ref state, runmatch))
            {
              this.runtext = (string) null;
              if (!reuseMatchObject)
                return;
              runmatch.Text = (string) null;
              return;
            }
            this.runtextstart = this.runtextpos;
            this.runtrackpos = this.runtrack.Length;
            this.runstackpos = this.runstack.Length;
            this.runcrawlpos = this.runcrawl.Length;
            if (runmatch.Length == 0)
            {
              if (this.runtextpos == num2)
              {
                this.runtext = (string) null;
                if (!reuseMatchObject)
                  return;
                runmatch.Text = (string) null;
                return;
              }
              this.runtextpos += num1;
            }
          }
          else
          {
            this.runtrackpos = this.runtrack.Length;
            this.runstackpos = this.runstack.Length;
            this.runcrawlpos = this.runcrawl.Length;
            break;
          }
        }
        if (this.runtextpos != num2)
          this.runtextpos += num1;
        else
          break;
      }
      this.runtext = (string) null;
      if (this.runmatch == null)
        return;
      this.runmatch.Text = (string) null;
    }

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected void CheckTimeout()
    {
      if (this._ignoreTimeout)
        return;
      this.DoCheckTimeout();
    }

    private void DoCheckTimeout()
    {
      if (--this._timeoutChecksToSkip != 0)
        return;
      this._timeoutChecksToSkip = 1000;
      int tickCount = Environment.TickCount;
      if (tickCount >= this._timeoutOccursAt && (0 <= this._timeoutOccursAt || 0 >= tickCount))
        throw new RegexMatchTimeoutException(this.runtext, this.runregex.pattern, TimeSpan.FromMilliseconds((double) this._timeout));
    }

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected abstract void Go();

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    /// <returns>Returns <see cref="T:System.Boolean" />.</returns>
    protected abstract bool FindFirstChar();

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected abstract void InitTrackCount();

    private void InitializeForGo()
    {
      if (this.runmatch == null)
        this.runmatch = this.runregex.caps == null ? new Match(this.runregex, this.runregex.capsize, this.runtext, this.runtextbeg, this.runtextend - this.runtextbeg, this.runtextstart) : (Match) new MatchSparse(this.runregex, this.runregex.caps, this.runregex.capsize, this.runtext, this.runtextbeg, this.runtextend - this.runtextbeg, this.runtextstart);
      else
        this.runmatch.Reset(this.runregex, this.runtext, this.runtextbeg, this.runtextend, this.runtextstart);
      if (this.runcrawl != null)
      {
        this.runtrackpos = this.runtrack.Length;
        this.runstackpos = this.runstack.Length;
        this.runcrawlpos = this.runcrawl.Length;
      }
      else
      {
        this.InitTrackCount();
        int length1;
        int length2 = length1 = this.runtrackcount * 8;
        if (length2 < 32)
          length2 = 32;
        if (length1 < 16)
          length1 = 16;
        this.runtrack = new int[length2];
        this.runtrackpos = length2;
        this.runstack = new int[length1];
        this.runstackpos = length1;
        this.runcrawl = new int[32];
        this.runcrawlpos = 32;
      }
    }

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected void EnsureStorage()
    {
      int num = this.runtrackcount * 4;
      if (this.runstackpos < num)
        this.DoubleStack();
      if (this.runtrackpos >= num)
        return;
      this.DoubleTrack();
    }

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    /// <param name="index">The possible boundary position.</param>
    /// <param name="startpos">The starting position.</param>
    /// <param name="endpos">The ending position.</param>
    /// <returns>Returns <see cref="T:System.Boolean" />.</returns>
    protected bool IsBoundary(int index, int startpos, int endpos) => (index <= startpos ? 0 : (RegexCharClass.IsWordChar(this.runtext[index - 1]) ? 1 : 0)) != (index >= endpos ? 0 : (RegexCharClass.IsWordChar(this.runtext[index]) ? 1 : 0));

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    /// <param name="index">The possible ECMA boundary position.</param>
    /// <param name="startpos">The starting position.</param>
    /// <param name="endpos">The ending position.</param>
    /// <returns>Returns <see cref="T:System.Boolean" />.</returns>
    protected bool IsECMABoundary(int index, int startpos, int endpos) => (index <= startpos ? 0 : (RegexCharClass.IsECMAWordChar(this.runtext[index - 1]) ? 1 : 0)) != (index >= endpos ? 0 : (RegexCharClass.IsECMAWordChar(this.runtext[index]) ? 1 : 0));


    #nullable enable
    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    /// <param name="ch">A character.</param>
    /// <param name="set">The character set.</param>
    /// <param name="category">The character category.</param>
    /// <returns>Returns <see cref="T:System.Boolean" />.</returns>
    protected static bool CharInSet(char ch, string set, string category)
    {
      string set1 = RegexCharClass.ConvertOldStringsToClass(set, category);
      return RegexCharClass.CharInClass(ch, set1);
    }

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method. Determines whether a character is in a character class.</summary>
    /// <param name="ch">A character to test.</param>
    /// <param name="charClass">The internal name of a character class.</param>
    /// <returns>
    /// <see langword="true" /> if the <paramref name="ch" /> parameter is in the character class specified by the <paramref name="charClass" /> parameter.</returns>
    protected static bool CharInClass(char ch, string charClass) => RegexCharClass.CharInClass(ch, charClass);

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected void DoubleTrack()
    {
      int[] destinationArray = new int[this.runtrack.Length * 2];
      Array.Copy((Array) this.runtrack, 0, (Array) destinationArray, this.runtrack.Length, this.runtrack.Length);
      this.runtrackpos += this.runtrack.Length;
      this.runtrack = destinationArray;
    }

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected void DoubleStack()
    {
      int[] destinationArray = new int[this.runstack.Length * 2];
      Array.Copy((Array) this.runstack, 0, (Array) destinationArray, this.runstack.Length, this.runstack.Length);
      this.runstackpos += this.runstack.Length;
      this.runstack = destinationArray;
    }

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected void DoubleCrawl()
    {
      int[] destinationArray = new int[this.runcrawl.Length * 2];
      Array.Copy((Array) this.runcrawl, 0, (Array) destinationArray, this.runcrawl.Length, this.runcrawl.Length);
      this.runcrawlpos += this.runcrawl.Length;
      this.runcrawl = destinationArray;
    }

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    /// <param name="i">A number to save.</param>
    protected void Crawl(int i)
    {
      if (this.runcrawlpos == 0)
        this.DoubleCrawl();
      this.runcrawl[--this.runcrawlpos] = i;
    }

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    /// <returns>Returns <see cref="T:System.Int32" />.</returns>
    protected int Popcrawl() => this.runcrawl[this.runcrawlpos++];

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    /// <returns>Returns <see cref="T:System.Int32" />.</returns>
    protected int Crawlpos() => this.runcrawl.Length - this.runcrawlpos;

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    /// <param name="capnum">A capture number.</param>
    /// <param name="start">The starting position of the capture.</param>
    /// <param name="end">The ending position of the capture.</param>
    protected void Capture(int capnum, int start, int end)
    {
      if (end < start)
      {
        int num = end;
        end = start;
        start = num;
      }
      this.Crawl(capnum);
      this.runmatch.AddMatch(capnum, start, end - start);
    }

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    /// <param name="capnum">A capture number.</param>
    /// <param name="uncapnum">A saved capture number.</param>
    /// <param name="start">The starting position.</param>
    /// <param name="end">The ending position.</param>
    protected void TransferCapture(int capnum, int uncapnum, int start, int end)
    {
      if (end < start)
      {
        int num = end;
        end = start;
        start = num;
      }
      int num1 = this.MatchIndex(uncapnum);
      int num2 = num1 + this.MatchLength(uncapnum);
      if (start >= num2)
      {
        end = start;
        start = num2;
      }
      else if (end <= num1)
      {
        start = num1;
      }
      else
      {
        if (end > num2)
          end = num2;
        if (num1 > start)
          start = num1;
      }
      this.Crawl(uncapnum);
      this.runmatch.BalanceMatch(uncapnum);
      if (capnum == -1)
        return;
      this.Crawl(capnum);
      this.runmatch.AddMatch(capnum, start, end - start);
    }

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected void Uncapture() => this.runmatch.RemoveMatch(this.Popcrawl());

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    /// <param name="cap">The capture number.</param>
    /// <returns>Returns <see cref="T:System.Boolean" />.</returns>
    protected bool IsMatched(int cap) => this.runmatch.IsMatched(cap);

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    /// <param name="cap">The capture number.</param>
    /// <returns>Returns <see cref="T:System.Int32" />.</returns>
    protected int MatchIndex(int cap) => this.runmatch.MatchIndex(cap);

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    /// <param name="cap">The capture number.</param>
    /// <returns>Returns <see cref="T:System.Int32" />.</returns>
    protected int MatchLength(int cap) => this.runmatch.MatchLength(cap);
  }
}
