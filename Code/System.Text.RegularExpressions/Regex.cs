// Decompiled with JetBrains decompiler
// Type: System.Text.RegularExpressions.Regex
// Assembly: System.Text.RegularExpressions, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// MVID: 9E234CFB-607D-4CAE-9C21-1A71C799D034
// Assembly location: C:\Program Files\dotnet\shared\Microsoft.NETCore.App\6.0.9\System.Text.RegularExpressions.dll
// XML documentation location: C:\Program Files\dotnet\packs\Microsoft.NETCore.App.Ref\6.0.9\ref\net6.0\System.Text.RegularExpressions.xml

using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Threading;


#nullable enable
namespace System.Text.RegularExpressions
{
  /// <summary>Represents an immutable regular expression.</summary>
  public class Regex : ISerializable
  {
    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected internal string? pattern;
    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected internal RegexOptions roptions;
    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected internal RegexRunnerFactory? factory;
    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected internal Hashtable? caps;
    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected internal Hashtable? capnames;
    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected internal string[]? capslist;
    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    protected internal int capsize;

    #nullable disable
    internal WeakReference<RegexReplacement> _replref;
    private volatile RegexRunner _runner;
    private RegexCode _code;
    private bool _refsInitialized;
    /// <summary>Specifies that a pattern-matching operation should not time out.</summary>
    public static readonly TimeSpan InfiniteMatchTimeout = Timeout.InfiniteTimeSpan;
    internal static readonly TimeSpan s_defaultMatchTimeout = Regex.InitDefaultMatchTimeout();
    /// <summary>The maximum amount of time that can elapse in a pattern-matching operation before the operation times out.</summary>
    protected internal TimeSpan internalMatchTimeout;

    /// <summary>Initializes a new instance of the <see cref="T:System.Text.RegularExpressions.Regex" /> class.</summary>
    protected Regex() => this.internalMatchTimeout = Regex.s_defaultMatchTimeout;


    #nullable enable
    /// <summary>Initializes a new instance of the <see cref="T:System.Text.RegularExpressions.Regex" /> class for the specified regular expression.</summary>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="pattern" /> is <see langword="null" />.</exception>
    public Regex(string pattern)
      : this(pattern, (CultureInfo) null)
    {
    }

    /// <summary>Initializes a new instance of the <see cref="T:System.Text.RegularExpressions.Regex" /> class for the specified regular expression, with options that modify the pattern.</summary>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <param name="options">A bitwise combination of the enumeration values that modify the regular expression.</param>
    /// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="pattern" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    /// <paramref name="options" /> contains an invalid flag.</exception>
    public Regex(string pattern, RegexOptions options)
      : this(pattern, options, Regex.s_defaultMatchTimeout, (CultureInfo) null)
    {
    }

    /// <summary>Initializes a new instance of the <see cref="T:System.Text.RegularExpressions.Regex" /> class for the specified regular expression, with options that modify the pattern and a value that specifies how long a pattern matching method should attempt a match before it times out.</summary>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <param name="options">A bitwise combination of the enumeration values that modify the regular expression.</param>
    /// <param name="matchTimeout">A time-out interval, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> to indicate that the method should not time out.</param>
    /// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="pattern" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///        <paramref name="options" /> is not a valid <see cref="T:System.Text.RegularExpressions.RegexOptions" /> value.
    /// 
    /// -or-
    /// 
    /// <paramref name="matchTimeout" /> is negative, zero, or greater than approximately 24 days.</exception>
    public Regex(string pattern, RegexOptions options, TimeSpan matchTimeout)
      : this(pattern, options, matchTimeout, (CultureInfo) null)
    {
    }


    #nullable disable
    internal Regex(string pattern, CultureInfo culture) => this.Init(pattern, RegexOptions.None, Regex.s_defaultMatchTimeout, culture);

    internal Regex(
      string pattern,
      RegexOptions options,
      TimeSpan matchTimeout,
      CultureInfo culture)
    {
      this.Init(pattern, options, matchTimeout, culture);
      if (!RuntimeFeature.IsDynamicCodeCompiled || !this.UseOptionC())
        return;
      this.factory = Regex.Compile(pattern, this._code, options, matchTimeout != Regex.InfiniteMatchTimeout);
      this._code = (RegexCode) null;
    }

    private void Init(
      string pattern,
      RegexOptions options,
      TimeSpan matchTimeout,
      CultureInfo culture)
    {
      Regex.ValidatePattern(pattern);
      Regex.ValidateOptions(options);
      Regex.ValidateMatchTimeout(matchTimeout);
      this.pattern = pattern;
      this.roptions = options;
      this.internalMatchTimeout = matchTimeout;
      RegexTree tree = RegexParser.Parse(pattern, this.roptions, culture ?? ((options & RegexOptions.CultureInvariant) != RegexOptions.None ? CultureInfo.InvariantCulture : CultureInfo.CurrentCulture));
      this.capnames = tree.CapNames;
      this.capslist = tree.CapsList;
      this._code = RegexWriter.Write(tree);
      this.caps = this._code.Caps;
      this.capsize = this._code.CapSize;
      this.InitializeReferences();
    }

    internal static void ValidatePattern(string pattern)
    {
      if (pattern != null)
        return;
      ThrowHelper.ThrowArgumentNullException(ExceptionArgument.pattern);
    }

    internal static void ValidateOptions(RegexOptions options)
    {
      if ((uint) options >> 10 == 0U && ((options & RegexOptions.ECMAScript) == RegexOptions.None || (options & ~(RegexOptions.IgnoreCase | RegexOptions.Multiline | RegexOptions.Compiled | RegexOptions.ECMAScript | RegexOptions.CultureInvariant)) == RegexOptions.None))
        return;
      ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.options);
    }

    /// <summary>Checks whether a time-out interval is within an acceptable range.</summary>
    /// <param name="matchTimeout">The time-out interval to check.</param>
    /// <exception cref="T:System.ArgumentOutOfRangeException">The specified time-out is not within a valid range.</exception>
    protected internal static void ValidateMatchTimeout(TimeSpan matchTimeout)
    {
      long ticks = matchTimeout.Ticks;
      if (ticks == -10000L || (ulong) ticks - 1UL < 21474836460000UL)
        return;
      ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.matchTimeout);
    }


    #nullable enable
    /// <summary>Initializes a new instance of the <see cref="T:System.Text.RegularExpressions.Regex" /> class by using serialized data.</summary>
    /// <param name="info">The object that contains a serialized pattern and <see cref="T:System.Text.RegularExpressions.RegexOptions" /> information.</param>
    /// <param name="context">The destination for this serialization. (This parameter is not used; specify <see langword="null" />.)</param>
    /// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
    /// <exception cref="T:System.ArgumentNullException">The pattern that <paramref name="info" /> contains is <see langword="null" />.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    /// <paramref name="info" /> contains an invalid <see cref="T:System.Text.RegularExpressions.RegexOptions" /> flag.</exception>
    protected Regex(SerializationInfo info, StreamingContext context) => throw new PlatformNotSupportedException();


    #nullable disable
    /// <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object with the data necessary to deserialize the current <see cref="T:System.Text.RegularExpressions.Regex" /> object.</summary>
    /// <param name="si">The object to populate with serialization information.</param>
    /// <param name="context">The place to store and retrieve serialized data. This parameter is reserved for future use.</param>
    void ISerializable.GetObjectData(SerializationInfo si, StreamingContext context) => throw new PlatformNotSupportedException();


    #nullable enable
    /// <summary>Gets or sets a dictionary that maps numbered capturing groups to their index values.</summary>
    /// <exception cref="T:System.ArgumentNullException">The value assigned to the <see cref="P:System.Text.RegularExpressions.Regex.Caps" /> property in a set operation is <see langword="null" />.</exception>
    /// <returns>A dictionary that maps numbered capturing groups to their index values.</returns>
    [CLSCompliant(false)]
    protected IDictionary? Caps
    {
      get => (IDictionary) this.caps;
      [param: DisallowNull] set
      {
        if (value == null)
          ThrowHelper.ThrowArgumentNullException(ExceptionArgument.value);
        if (!(value is Hashtable hashtable))
          hashtable = new Hashtable(value);
        this.caps = hashtable;
      }
    }

    /// <summary>Gets or sets a dictionary that maps named capturing groups to their index values.</summary>
    /// <exception cref="T:System.ArgumentNullException">The value assigned to the <see cref="P:System.Text.RegularExpressions.Regex.CapNames" /> property in a set operation is <see langword="null" />.</exception>
    /// <returns>A dictionary that maps named capturing groups to their index values.</returns>
    [CLSCompliant(false)]
    protected IDictionary? CapNames
    {
      get => (IDictionary) this.capnames;
      [param: DisallowNull] set
      {
        if (value == null)
          ThrowHelper.ThrowArgumentNullException(ExceptionArgument.value);
        if (!(value is Hashtable hashtable))
          hashtable = new Hashtable(value);
        this.capnames = hashtable;
      }
    }


    #nullable disable
    [MethodImpl(MethodImplOptions.NoInlining)]
    private static RegexRunnerFactory Compile(
      string pattern,
      RegexCode code,
      RegexOptions options,
      bool hasTimeout)
    {
      return RegexCompiler.Compile(pattern, code, options, hasTimeout);
    }


    #nullable enable
    /// <summary>Compiles one or more specified <see cref="T:System.Text.RegularExpressions.Regex" /> objects to a named assembly.</summary>
    /// <param name="regexinfos">An array that describes the regular expressions to compile.</param>
    /// <param name="assemblyname">The file name of the assembly.</param>
    /// <exception cref="T:System.ArgumentException">The value of the <paramref name="assemblyname" /> parameter's <see cref="P:System.Reflection.AssemblyName.Name" /> property is an empty or null string.
    /// 
    /// -or-
    /// 
    /// The regular expression pattern of one or more objects in <paramref name="regexinfos" /> contains invalid syntax.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="assemblyname" /> or <paramref name="regexinfos" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.PlatformNotSupportedException">.NET Core and .NET 5+ only: Creating an assembly of compiled regular expressions is not supported.</exception>
    public static void CompileToAssembly(
      RegexCompilationInfo[] regexinfos,
      AssemblyName assemblyname)
    {
      Regex.CompileToAssembly(regexinfos, assemblyname, (CustomAttributeBuilder[]) null, (string) null);
    }

    /// <summary>Compiles one or more specified <see cref="T:System.Text.RegularExpressions.Regex" /> objects to a named assembly with the specified attributes.</summary>
    /// <param name="regexinfos">An array that describes the regular expressions to compile.</param>
    /// <param name="assemblyname">The file name of the assembly.</param>
    /// <param name="attributes">An array that defines the attributes to apply to the assembly.</param>
    /// <exception cref="T:System.ArgumentException">The value of the <paramref name="assemblyname" /> parameter's <see cref="P:System.Reflection.AssemblyName.Name" /> property is an empty or null string.
    /// 
    /// -or-
    /// 
    /// The regular expression pattern of one or more objects in <paramref name="regexinfos" /> contains invalid syntax.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="assemblyname" /> or <paramref name="regexinfos" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.PlatformNotSupportedException">.NET Core and .NET 5+ only: Creating an assembly of compiled regular expressions is not supported.</exception>
    public static void CompileToAssembly(
      RegexCompilationInfo[] regexinfos,
      AssemblyName assemblyname,
      CustomAttributeBuilder[]? attributes)
    {
      Regex.CompileToAssembly(regexinfos, assemblyname, attributes, (string) null);
    }

    /// <summary>Compiles one or more specified <see cref="T:System.Text.RegularExpressions.Regex" /> objects and a specified resource file to a named assembly with the specified attributes.</summary>
    /// <param name="regexinfos">An array that describes the regular expressions to compile.</param>
    /// <param name="assemblyname">The file name of the assembly.</param>
    /// <param name="attributes">An array that defines the attributes to apply to the assembly.</param>
    /// <param name="resourceFile">The name of the Win32 resource file to include in the assembly.</param>
    /// <exception cref="T:System.ArgumentException">The value of the <paramref name="assemblyname" /> parameter's <see cref="P:System.Reflection.AssemblyName.Name" /> property is an empty or null string.
    /// 
    /// -or-
    /// 
    /// The regular expression pattern of one or more objects in <paramref name="regexinfos" /> contains invalid syntax.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="assemblyname" /> or <paramref name="regexinfos" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.Runtime.InteropServices.COMException">The <paramref name="resourceFile" /> parameter designates an invalid Win32 resource file.</exception>
    /// <exception cref="T:System.IO.FileNotFoundException">The file designated by the <paramref name="resourceFile" /> parameter cannot be found.</exception>
    /// <exception cref="T:System.PlatformNotSupportedException">.NET Core and .NET 5+ only: Creating an assembly of compiled regular expressions is not supported.</exception>
    public static void CompileToAssembly(
      RegexCompilationInfo[] regexinfos,
      AssemblyName assemblyname,
      CustomAttributeBuilder[]? attributes,
      string? resourceFile)
    {
      if (assemblyname == null)
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.assemblyname);
      if (regexinfos == null)
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.regexinfos);
      throw new PlatformNotSupportedException(SR.PlatformNotSupported_CompileToAssembly);
    }

    /// <summary>Escapes a minimal set of characters (\, *, +, ?, |, {, [, (,), ^, $, ., #, and white space) by replacing them with their escape codes. This instructs the regular expression engine to interpret these characters literally rather than as metacharacters.</summary>
    /// <param name="str">The input string that contains the text to convert.</param>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="str" /> is <see langword="null" />.</exception>
    /// <returns>A string of characters with metacharacters converted to their escaped form.</returns>
    public static string Escape(string str)
    {
      if (str == null)
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.str);
      return RegexParser.Escape(str);
    }

    /// <summary>Converts any escaped characters in the input string.</summary>
    /// <param name="str">The input string containing the text to convert.</param>
    /// <exception cref="T:System.ArgumentException">
    /// <paramref name="str" /> includes an unrecognized escape sequence.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="str" /> is <see langword="null" />.</exception>
    /// <returns>A string of characters with any escaped characters converted to their unescaped form.</returns>
    public static string Unescape(string str)
    {
      if (str == null)
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.str);
      return RegexParser.Unescape(str);
    }

    /// <summary>Gets the options that were passed into the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor.</summary>
    /// <returns>One or more members of the <see cref="T:System.Text.RegularExpressions.RegexOptions" /> enumeration that represent options that were passed to the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor.</returns>
    public RegexOptions Options => this.roptions;

    /// <summary>Gets a value that indicates whether the regular expression searches from right to left.</summary>
    /// <returns>
    /// <see langword="true" /> if the regular expression searches from right to left; otherwise, <see langword="false" />.</returns>
    public bool RightToLeft => this.UseOptionR();

    /// <summary>Returns the regular expression pattern that was passed into the <see langword="Regex" /> constructor.</summary>
    /// <returns>The <paramref name="pattern" /> parameter that was passed into the <see langword="Regex" /> constructor.</returns>
    public override string ToString() => this.pattern;

    /// <summary>Returns an array of capturing group names for the regular expression.</summary>
    /// <returns>A string array of group names.</returns>
    public string[] GetGroupNames()
    {
      string[] groupNames;
      if (this.capslist == null)
      {
        groupNames = new string[this.capsize];
        for (int index = 0; index < groupNames.Length; ++index)
          groupNames[index] = ((uint) index).ToString();
      }
      else
        groupNames = this.capslist.AsSpan<string>().ToArray();
      return groupNames;
    }

    /// <summary>Returns an array of capturing group numbers that correspond to group names in an array.</summary>
    /// <returns>An integer array of group numbers.</returns>
    public int[] GetGroupNumbers()
    {
      int[] groupNumbers;
      if (this.caps == null)
      {
        groupNumbers = new int[this.capsize];
        for (int index = 0; index < groupNumbers.Length; ++index)
          groupNumbers[index] = index;
      }
      else
      {
        groupNumbers = new int[this.caps.Count];
        IDictionaryEnumerator enumerator = this.caps.GetEnumerator();
        while (enumerator.MoveNext())
          groupNumbers[(int) enumerator.Value] = (int) enumerator.Key;
      }
      return groupNumbers;
    }

    /// <summary>Gets the group name that corresponds to the specified group number.</summary>
    /// <param name="i">The group number to convert to the corresponding group name.</param>
    /// <returns>A string that contains the group name associated with the specified group number. If there is no group name that corresponds to <paramref name="i" />, the method returns <see cref="F:System.String.Empty" />.</returns>
    public string GroupNameFromNumber(int i) => this.capslist == null ? ((uint) i >= (uint) this.capsize ? string.Empty : ((uint) i).ToString()) : ((this.caps == null || this.caps.TryGetValue<int>((object) i, out i)) && (uint) i < (uint) this.capslist.Length ? this.capslist[i] : string.Empty);

    /// <summary>Returns the group number that corresponds to the specified group name.</summary>
    /// <param name="name">The group name to convert to the corresponding group number.</param>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="name" /> is <see langword="null" />.</exception>
    /// <returns>The group number that corresponds to the specified group name, or -1 if <paramref name="name" /> is not a valid group name.</returns>
    public int GroupNumberFromName(string name)
    {
      if (name == null)
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.name);
      int num;
      uint result;
      return this.capnames != null ? (!this.capnames.TryGetValue<int>((object) name, out num) ? -1 : num) : (!uint.TryParse(name, NumberStyles.None, (IFormatProvider) CultureInfo.InvariantCulture, out result) || (long) result >= (long) this.capsize ? -1 : (int) result);
    }

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    /// <exception cref="T:System.NotSupportedException">References have already been initialized.</exception>
    protected void InitializeReferences()
    {
      if (this._refsInitialized)
        ThrowHelper.ThrowNotSupportedException(ExceptionResource.OnlyAllowedOnce);
      this._replref = new WeakReference<RegexReplacement>((RegexReplacement) null);
      this._refsInitialized = true;
    }


    #nullable disable
    internal System.Text.RegularExpressions.Match Run(
      bool quick,
      int prevlen,
      string input,
      int beginning,
      int length,
      int startat)
    {
      if ((uint) startat > (uint) input.Length)
        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.startat, ExceptionResource.BeginIndexNotNegative);
      if ((uint) length > (uint) input.Length)
        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.length, ExceptionResource.LengthNotNegative);
      RegexRunner runner = this.RentRunner();
      try
      {
        return runner.Scan(this, input, beginning, beginning + length, startat, prevlen, quick, this.internalMatchTimeout);
      }
      finally
      {
        this.ReturnRunner(runner);
      }
    }

    internal void Run<TState>(
      string input,
      int startat,
      ref TState state,
      MatchCallback<TState> callback,
      bool reuseMatchObject)
    {
      RegexRunner runner = this.RentRunner();
      try
      {
        runner.Scan<TState>(this, input, startat, ref state, callback, reuseMatchObject, this.internalMatchTimeout);
      }
      finally
      {
        this.ReturnRunner(runner);
      }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private RegexRunner RentRunner()
    {
      RegexRunner regexRunner = Interlocked.Exchange<RegexRunner>(ref this._runner, (RegexRunner) null);
      if (regexRunner != null)
        return regexRunner;
      return this.factory == null ? (RegexRunner) new RegexInterpreter(this._code, this.UseOptionInvariant() ? CultureInfo.InvariantCulture : CultureInfo.CurrentCulture) : this.factory.CreateInstance();
    }

    internal void ReturnRunner(RegexRunner runner) => this._runner = runner;

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    /// <returns>
    /// <see langword="true" /> if the <see cref="P:System.Text.RegularExpressions.Regex.Options" /> property contains the <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> option; otherwise, <see langword="false" />.</returns>
    protected bool UseOptionC() => (this.roptions & RegexOptions.Compiled) != 0;

    /// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
    /// <returns>
    /// <see langword="true" /> if the <see cref="P:System.Text.RegularExpressions.Regex.Options" /> property contains the <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /> option; otherwise, <see langword="false" />.</returns>
    protected internal bool UseOptionR() => (this.roptions & RegexOptions.RightToLeft) != 0;

    internal bool UseOptionInvariant() => (this.roptions & RegexOptions.CultureInvariant) != 0;

    /// <summary>Gets or sets the maximum number of entries in the current static cache of compiled regular expressions.</summary>
    /// <exception cref="T:System.ArgumentOutOfRangeException">The value in a set operation is less than zero.</exception>
    /// <returns>The maximum number of entries in the static cache.</returns>
    public static int CacheSize
    {
      get => RegexCache.MaxCacheSize;
      set
      {
        if (value < 0)
          ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.value);
        RegexCache.MaxCacheSize = value;
      }
    }


    #nullable enable
    /// <summary>Indicates whether the specified regular expression finds a match in the specified input string.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>
    /// <see langword="true" /> if the regular expression finds a match; otherwise, <see langword="false" />.</returns>
    public static bool IsMatch(string input, string pattern) => RegexCache.GetOrAdd(pattern).IsMatch(input);

    /// <summary>Indicates whether the specified regular expression finds a match in the specified input string, using the specified matching options.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <param name="options">A bitwise combination of the enumeration values that provide options for matching.</param>
    /// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    /// <paramref name="options" /> is not a valid <see cref="T:System.Text.RegularExpressions.RegexOptions" /> value.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>
    /// <see langword="true" /> if the regular expression finds a match; otherwise, <see langword="false" />.</returns>
    public static bool IsMatch(string input, string pattern, RegexOptions options) => RegexCache.GetOrAdd(pattern, options, Regex.s_defaultMatchTimeout).IsMatch(input);

    /// <summary>Indicates whether the specified regular expression finds a match in the specified input string, using the specified matching options and time-out interval.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <param name="options">A bitwise combination of the enumeration values that provide options for matching.</param>
    /// <param name="matchTimeout">A time-out interval, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> to indicate that the method should not time out.</param>
    /// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///        <paramref name="options" /> is not a valid <see cref="T:System.Text.RegularExpressions.RegexOptions" /> value.
    /// 
    /// -or-
    /// 
    /// <paramref name="matchTimeout" /> is negative, zero, or greater than approximately 24 days.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred.</exception>
    /// <returns>
    /// <see langword="true" /> if the regular expression finds a match; otherwise, <see langword="false" />.</returns>
    public static bool IsMatch(
      string input,
      string pattern,
      RegexOptions options,
      TimeSpan matchTimeout)
    {
      return RegexCache.GetOrAdd(pattern, options, matchTimeout).IsMatch(input);
    }

    /// <summary>Indicates whether the regular expression specified in the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor finds a match in a specified input string.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>
    /// <see langword="true" /> if the regular expression finds a match; otherwise, <see langword="false" />.</returns>
    public bool IsMatch(string input)
    {
      if (input == null)
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.input);
      return this.Run(true, -1, input, 0, input.Length, this.UseOptionR() ? input.Length : 0) == null;
    }

    /// <summary>Indicates whether the regular expression specified in the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor finds a match in the specified input string, beginning at the specified starting position in the string.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="startat">The character position at which to start the search.</param>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    /// <paramref name="startat" /> is less than zero or greater than the length of <paramref name="input" />.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>
    /// <see langword="true" /> if the regular expression finds a match; otherwise, <see langword="false" />.</returns>
    public bool IsMatch(string input, int startat)
    {
      if (input == null)
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.input);
      return this.Run(true, -1, input, 0, input.Length, startat) == null;
    }

    /// <summary>Searches the specified input string for the first occurrence of the specified regular expression.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>An object that contains information about the match.</returns>
    public static System.Text.RegularExpressions.Match Match(string input, string pattern) => RegexCache.GetOrAdd(pattern).Match(input);

    /// <summary>Searches the input string for the first occurrence of the specified regular expression, using the specified matching options.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <param name="options">A bitwise combination of the enumeration values that provide options for matching.</param>
    /// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    /// <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>An object that contains information about the match.</returns>
    public static System.Text.RegularExpressions.Match Match(
      string input,
      string pattern,
      RegexOptions options)
    {
      return RegexCache.GetOrAdd(pattern, options, Regex.s_defaultMatchTimeout).Match(input);
    }

    /// <summary>Searches the input string for the first occurrence of the specified regular expression, using the specified matching options and time-out interval.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <param name="options">A bitwise combination of the enumeration values that provide options for matching.</param>
    /// <param name="matchTimeout">A time-out interval, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> to indicate that the method should not time out.</param>
    /// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///        <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.
    /// 
    /// -or-
    /// 
    /// <paramref name="matchTimeout" /> is negative, zero, or greater than approximately 24 days.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>An object that contains information about the match.</returns>
    public static System.Text.RegularExpressions.Match Match(
      string input,
      string pattern,
      RegexOptions options,
      TimeSpan matchTimeout)
    {
      return RegexCache.GetOrAdd(pattern, options, matchTimeout).Match(input);
    }

    /// <summary>Searches the specified input string for the first occurrence of the regular expression specified in the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>An object that contains information about the match.</returns>
    public System.Text.RegularExpressions.Match Match(string input)
    {
      if (input == null)
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.input);
      return this.Run(false, -1, input, 0, input.Length, this.UseOptionR() ? input.Length : 0);
    }

    /// <summary>Searches the input string for the first occurrence of a regular expression, beginning at the specified starting position in the string.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="startat">The zero-based character position at which to start the search.</param>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    /// <paramref name="startat" /> is less than zero or greater than the length of <paramref name="input" />.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>An object that contains information about the match.</returns>
    public System.Text.RegularExpressions.Match Match(string input, int startat)
    {
      if (input == null)
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.input);
      return this.Run(false, -1, input, 0, input.Length, startat);
    }

    /// <summary>Searches the input string for the first occurrence of a regular expression, beginning at the specified starting position and searching only the specified number of characters.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="beginning">The zero-based character position in the input string that defines the leftmost position to be searched.</param>
    /// <param name="length">The number of characters in the substring to include in the search.</param>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///        <paramref name="beginning" /> is less than zero or greater than the length of <paramref name="input" />.
    /// 
    /// -or-
    /// 
    /// <paramref name="length" /> is less than zero or greater than the length of <paramref name="input" />.
    /// 
    /// -or-
    /// 
    /// <paramref name="beginning" /><see langword="+" /><paramref name="length" /><see langword="-1" /> identifies a position that is outside the range of <paramref name="input" />.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>An object that contains information about the match.</returns>
    public System.Text.RegularExpressions.Match Match(string input, int beginning, int length)
    {
      if (input == null)
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.input);
      return this.Run(false, -1, input, beginning, length, this.UseOptionR() ? beginning + length : beginning);
    }

    /// <summary>Searches the specified input string for all occurrences of a specified regular expression.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</exception>
    /// <returns>A collection of the <see cref="T:System.Text.RegularExpressions.Match" /> objects found by the search. If no matches are found, the method returns an empty collection object.</returns>
    public static MatchCollection Matches(string input, string pattern) => RegexCache.GetOrAdd(pattern).Matches(input);

    /// <summary>Searches the specified input string for all occurrences of a specified regular expression, using the specified matching options.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <param name="options">A bitwise combination of the enumeration values that specify options for matching.</param>
    /// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    /// <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.</exception>
    /// <returns>A collection of the <see cref="T:System.Text.RegularExpressions.Match" /> objects found by the search. If no matches are found, the method returns an empty collection object.</returns>
    public static MatchCollection Matches(
      string input,
      string pattern,
      RegexOptions options)
    {
      return RegexCache.GetOrAdd(pattern, options, Regex.s_defaultMatchTimeout).Matches(input);
    }

    /// <summary>Searches the specified input string for all occurrences of a specified regular expression, using the specified matching options and time-out interval.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <param name="options">A bitwise combination of the enumeration values that specify options for matching.</param>
    /// <param name="matchTimeout">A time-out interval, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> to indicate that the method should not time out.</param>
    /// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///        <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.
    /// 
    /// -or-
    /// 
    /// <paramref name="matchTimeout" /> is negative, zero, or greater than approximately 24 days.</exception>
    /// <returns>A collection of the <see cref="T:System.Text.RegularExpressions.Match" /> objects found by the search. If no matches are found, the method returns an empty collection object.</returns>
    public static MatchCollection Matches(
      string input,
      string pattern,
      RegexOptions options,
      TimeSpan matchTimeout)
    {
      return RegexCache.GetOrAdd(pattern, options, matchTimeout).Matches(input);
    }

    /// <summary>Searches the specified input string for all occurrences of a regular expression.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> is <see langword="null" />.</exception>
    /// <returns>A collection of the <see cref="T:System.Text.RegularExpressions.Match" /> objects found by the search. If no matches are found, the method returns an empty collection object.</returns>
    public MatchCollection Matches(string input)
    {
      if (input == null)
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.input);
      return new MatchCollection(this, input, this.UseOptionR() ? input.Length : 0);
    }

    /// <summary>Searches the specified input string for all occurrences of a regular expression, beginning at the specified starting position in the string.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="startat">The character position in the input string at which to start the search.</param>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    /// <paramref name="startat" /> is less than zero or greater than the length of <paramref name="input" />.</exception>
    /// <returns>A collection of the <see cref="T:System.Text.RegularExpressions.Match" /> objects found by the search. If no matches are found, the method returns an empty collection object.</returns>
    public MatchCollection Matches(string input, int startat)
    {
      if (input == null)
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.input);
      return new MatchCollection(this, input, startat);
    }

    /// <summary>In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <param name="replacement">The replacement string.</param>
    /// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" />, <paramref name="pattern" />, or <paramref name="replacement" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>A new string that is identical to the input string, except that the replacement string takes the place of each matched string. If <paramref name="pattern" /> is not matched in the current instance, the method returns the current instance unchanged.</returns>
    public static string Replace(string input, string pattern, string replacement) => RegexCache.GetOrAdd(pattern).Replace(input, replacement);

    /// <summary>In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string. Specified options modify the matching operation.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <param name="replacement">The replacement string.</param>
    /// <param name="options">A bitwise combination of the enumeration values that provide options for matching.</param>
    /// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" />, <paramref name="pattern" />, or <paramref name="replacement" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    /// <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>A new string that is identical to the input string, except that the replacement string takes the place of each matched string. If <paramref name="pattern" /> is not matched in the current instance, the method returns the current instance unchanged.</returns>
    public static string Replace(
      string input,
      string pattern,
      string replacement,
      RegexOptions options)
    {
      return RegexCache.GetOrAdd(pattern, options, Regex.s_defaultMatchTimeout).Replace(input, replacement);
    }

    /// <summary>In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string. Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <param name="replacement">The replacement string.</param>
    /// <param name="options">A bitwise combination of the enumeration values that provide options for matching.</param>
    /// <param name="matchTimeout">A time-out interval, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> to indicate that the method should not time out.</param>
    /// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" />, <paramref name="pattern" />, or <paramref name="replacement" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///        <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.
    /// 
    /// -or-
    /// 
    /// <paramref name="matchTimeout" /> is negative, zero, or greater than approximately 24 days.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>A new string that is identical to the input string, except that the replacement string takes the place of each matched string. If <paramref name="pattern" /> is not matched in the current instance, the method returns the current instance unchanged.</returns>
    public static string Replace(
      string input,
      string pattern,
      string replacement,
      RegexOptions options,
      TimeSpan matchTimeout)
    {
      return RegexCache.GetOrAdd(pattern, options, matchTimeout).Replace(input, replacement);
    }

    /// <summary>In a specified input string, replaces all strings that match a regular expression pattern with a specified replacement string.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="replacement">The replacement string.</param>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> or <paramref name="replacement" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>A new string that is identical to the input string, except that the replacement string takes the place of each matched string. If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</returns>
    public string Replace(string input, string replacement)
    {
      if (input == null)
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.input);
      return this.Replace(input, replacement, -1, this.UseOptionR() ? input.Length : 0);
    }

    /// <summary>In a specified input string, replaces a specified maximum number of strings that match a regular expression pattern with a specified replacement string.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="replacement">The replacement string.</param>
    /// <param name="count">The maximum number of times the replacement can occur.</param>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> or <paramref name="replacement" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>A new string that is identical to the input string, except that the replacement string takes the place of each matched string. If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</returns>
    public string Replace(string input, string replacement, int count)
    {
      if (input == null)
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.input);
      return this.Replace(input, replacement, count, this.UseOptionR() ? input.Length : 0);
    }

    /// <summary>In a specified input substring, replaces a specified maximum number of strings that match a regular expression pattern with a specified replacement string.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="replacement">The replacement string.</param>
    /// <param name="count">Maximum number of times the replacement can occur.</param>
    /// <param name="startat">The character position in the input string where the search begins.</param>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> or <paramref name="replacement" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    /// <paramref name="startat" /> is less than zero or greater than the length of <paramref name="input" />.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>A new string that is identical to the input string, except that the replacement string takes the place of each matched string. If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</returns>
    public string Replace(string input, string replacement, int count, int startat)
    {
      if (input == null)
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.input);
      if (replacement == null)
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.replacement);
      return RegexReplacement.GetOrCreate(this._replref, replacement, this.caps, this.capsize, this.capnames, this.roptions).Replace(this, input, count, startat);
    }

    /// <summary>In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegate.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <param name="evaluator">A custom method that examines each match and returns either the original matched string or a replacement string.</param>
    /// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" />, <paramref name="pattern" />, or <paramref name="evaluator" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>A new string that is identical to the input string, except that a replacement string takes the place of each matched string. If <paramref name="pattern" /> is not matched in the current instance, the method returns the current instance unchanged.</returns>
    public static string Replace(string input, string pattern, MatchEvaluator evaluator) => RegexCache.GetOrAdd(pattern).Replace(input, evaluator);

    /// <summary>In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegate. Specified options modify the matching operation.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <param name="evaluator">A custom method that examines each match and returns either the original matched string or a replacement string.</param>
    /// <param name="options">A bitwise combination of the enumeration values that provide options for matching.</param>
    /// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" />, <paramref name="pattern" />, or <paramref name="evaluator" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    /// <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>A new string that is identical to the input string, except that a replacement string takes the place of each matched string. If <paramref name="pattern" /> is not matched in the current instance, the method returns the current instance unchanged.</returns>
    public static string Replace(
      string input,
      string pattern,
      MatchEvaluator evaluator,
      RegexOptions options)
    {
      return RegexCache.GetOrAdd(pattern, options, Regex.s_defaultMatchTimeout).Replace(input, evaluator);
    }

    /// <summary>In a specified input string, replaces all substrings that match a specified regular expression with a string returned by a <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegate. Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <param name="evaluator">A custom method that examines each match and returns either the original matched string or a replacement string.</param>
    /// <param name="options">A bitwise combination of enumeration values that provide options for matching.</param>
    /// <param name="matchTimeout">A time-out interval, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> to indicate that the method should not time out.</param>
    /// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" />, <paramref name="pattern" />, or <paramref name="evaluator" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///        <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.
    /// 
    /// -or-
    /// 
    /// <paramref name="matchTimeout" /> is negative, zero, or greater than approximately 24 days.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>A new string that is identical to the input string, except that the replacement string takes the place of each matched string. If <paramref name="pattern" /> is not matched in the current instance, the method returns the current instance unchanged.</returns>
    public static string Replace(
      string input,
      string pattern,
      MatchEvaluator evaluator,
      RegexOptions options,
      TimeSpan matchTimeout)
    {
      return RegexCache.GetOrAdd(pattern, options, matchTimeout).Replace(input, evaluator);
    }

    /// <summary>In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegate.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="evaluator">A custom method that examines each match and returns either the original matched string or a replacement string.</param>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> or <paramref name="evaluator" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>A new string that is identical to the input string, except that a replacement string takes the place of each matched string. If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</returns>
    public string Replace(string input, MatchEvaluator evaluator)
    {
      if (input == null)
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.input);
      return Regex.Replace(evaluator, this, input, -1, this.UseOptionR() ? input.Length : 0);
    }

    /// <summary>In a specified input string, replaces a specified maximum number of strings that match a regular expression pattern with a string returned by a <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegate.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="evaluator">A custom method that examines each match and returns either the original matched string or a replacement string.</param>
    /// <param name="count">The maximum number of times the replacement will occur.</param>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> or <paramref name="evaluator" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>A new string that is identical to the input string, except that a replacement string takes the place of each matched string. If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</returns>
    public string Replace(string input, MatchEvaluator evaluator, int count)
    {
      if (input == null)
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.input);
      return Regex.Replace(evaluator, this, input, count, this.UseOptionR() ? input.Length : 0);
    }

    /// <summary>In a specified input substring, replaces a specified maximum number of strings that match a regular expression pattern with a string returned by a <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegate.</summary>
    /// <param name="input">The string to search for a match.</param>
    /// <param name="evaluator">A custom method that examines each match and returns either the original matched string or a replacement string.</param>
    /// <param name="count">The maximum number of times the replacement will occur.</param>
    /// <param name="startat">The character position in the input string where the search begins.</param>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> or <paramref name="evaluator" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    /// <paramref name="startat" /> is less than zero or greater than the length of <paramref name="input" />.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>A new string that is identical to the input string, except that a replacement string takes the place of each matched string. If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.</returns>
    public string Replace(string input, MatchEvaluator evaluator, int count, int startat)
    {
      if (input == null)
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.input);
      return Regex.Replace(evaluator, this, input, count, startat);
    }


    #nullable disable
    private static string Replace(
      MatchEvaluator evaluator,
      Regex regex,
      string input,
      int count,
      int startat)
    {
      if (evaluator == null)
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.evaluator);
      if (count < -1)
        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.count, ExceptionResource.CountTooSmall);
      if ((uint) startat > (uint) input.Length)
        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.startat, ExceptionResource.BeginIndexNotNegative);
      if (count == 0)
        return input;
      (SegmentStringBuilder, MatchEvaluator, int, string, int) state1 = (SegmentStringBuilder.Create(), evaluator, 0, input, count);
      if (!regex.RightToLeft)
      {
        regex.Run<(SegmentStringBuilder, MatchEvaluator, int, string, int)>(input, startat, ref state1, (MatchCallback<(SegmentStringBuilder, MatchEvaluator, int, string, int)>) ((ref (SegmentStringBuilder segments, MatchEvaluator evaluator, int prevat, string input, int count) state, System.Text.RegularExpressions.Match match) =>
        {
          state.Item1.Add(state.Item4.AsMemory(state.Item3, match.Index - state.Item3));
          state.Item3 = match.Index + match.Length;
          state.Item1.Add(state.Item2(match).AsMemory());
          return --state.Item5 != 0;
        }), false);
        if (state1.Item1.Count == 0)
          return input;
        state1.Item1.Add(input.AsMemory(state1.Item3, input.Length - state1.Item3));
      }
      else
      {
        state1.Item3 = input.Length;
        regex.Run<(SegmentStringBuilder, MatchEvaluator, int, string, int)>(input, startat, ref state1, (MatchCallback<(SegmentStringBuilder, MatchEvaluator, int, string, int)>) ((ref (SegmentStringBuilder segments, MatchEvaluator evaluator, int prevat, string input, int count) state, System.Text.RegularExpressions.Match match) =>
        {
          state.Item1.Add(state.Item4.AsMemory(match.Index + match.Length, state.Item3 - match.Index - match.Length));
          state.Item3 = match.Index;
          state.Item1.Add(state.Item2(match).AsMemory());
          return --state.Item5 != 0;
        }), false);
        if (state1.Item1.Count == 0)
          return input;
        state1.Item1.Add(input.AsMemory(0, state1.Item3));
        state1.Item1.AsSpan().Reverse<ReadOnlyMemory<char>>();
      }
      return state1.Item1.ToString();
    }


    #nullable enable
    /// <summary>Splits an input string into an array of substrings at the positions defined by a regular expression pattern.</summary>
    /// <param name="input">The string to split.</param>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>An array of strings.</returns>
    public static string[] Split(string input, string pattern) => RegexCache.GetOrAdd(pattern).Split(input);

    /// <summary>Splits an input string into an array of substrings at the positions defined by a specified regular expression pattern. Specified options modify the matching operation.</summary>
    /// <param name="input">The string to split.</param>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <param name="options">A bitwise combination of the enumeration values that provide options for matching.</param>
    /// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    /// <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>An array of strings.</returns>
    public static string[] Split(string input, string pattern, RegexOptions options) => RegexCache.GetOrAdd(pattern, options, Regex.s_defaultMatchTimeout).Split(input);

    /// <summary>Splits an input string into an array of substrings at the positions defined by a specified regular expression pattern. Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</summary>
    /// <param name="input">The string to split.</param>
    /// <param name="pattern">The regular expression pattern to match.</param>
    /// <param name="options">A bitwise combination of the enumeration values that provide options for matching.</param>
    /// <param name="matchTimeout">A time-out interval, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> to indicate that the method should not time out.</param>
    /// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> or <paramref name="pattern" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    ///        <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.
    /// 
    /// -or-
    /// 
    /// <paramref name="matchTimeout" /> is negative, zero, or greater than approximately 24 days.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>A string array.</returns>
    public static string[] Split(
      string input,
      string pattern,
      RegexOptions options,
      TimeSpan matchTimeout)
    {
      return RegexCache.GetOrAdd(pattern, options, matchTimeout).Split(input);
    }

    /// <summary>Splits an input string into an array of substrings at the positions defined by a regular expression pattern specified in the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor.</summary>
    /// <param name="input">The string to split.</param>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>An array of strings.</returns>
    public string[] Split(string input)
    {
      if (input == null)
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.input);
      return Regex.Split(this, input, 0, this.UseOptionR() ? input.Length : 0);
    }

    /// <summary>Splits an input string a specified maximum number of times into an array of substrings, at the positions defined by a regular expression specified in the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor.</summary>
    /// <param name="input">The string to be split.</param>
    /// <param name="count">The maximum number of times the split can occur.</param>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>An array of strings.</returns>
    public string[] Split(string input, int count)
    {
      if (input == null)
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.input);
      return Regex.Split(this, input, count, this.UseOptionR() ? input.Length : 0);
    }

    /// <summary>Splits an input string a specified maximum number of times into an array of substrings, at the positions defined by a regular expression specified in the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor. The search for the regular expression pattern starts at a specified character position in the input string.</summary>
    /// <param name="input">The string to be split.</param>
    /// <param name="count">The maximum number of times the split can occur.</param>
    /// <param name="startat">The character position in the input string where the search will begin.</param>
    /// <exception cref="T:System.ArgumentNullException">
    /// <paramref name="input" /> is <see langword="null" />.</exception>
    /// <exception cref="T:System.ArgumentOutOfRangeException">
    /// <paramref name="startat" /> is less than zero or greater than the length of <paramref name="input" />.</exception>
    /// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
    /// <returns>An array of strings.</returns>
    public string[] Split(string input, int count, int startat)
    {
      if (input == null)
        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.input);
      return Regex.Split(this, input, count, startat);
    }


    #nullable disable
    private static string[] Split(Regex regex, string input, int count, int startat)
    {
      if (count < 0)
        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.count, ExceptionResource.CountTooSmall);
      if ((uint) startat > (uint) input.Length)
        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.startat, ExceptionResource.BeginIndexNotNegative);
      if (count == 1)
        return new string[1]{ input };
      --count;
      (List<string>, int, string, int) state1 = (new List<string>(), 0, input, count);
      if (!regex.RightToLeft)
      {
        regex.Run<(List<string>, int, string, int)>(input, startat, ref state1, (MatchCallback<(List<string>, int, string, int)>) ((ref (List<string> results, int prevat, string input, int count) state, System.Text.RegularExpressions.Match match) =>
        {
          state.Item1.Add(state.Item3.Substring(state.Item2, match.Index - state.Item2));
          state.Item2 = match.Index + match.Length;
          for (int index = 1; index < match.Groups.Count; ++index)
          {
            if (match.IsMatched(index))
              state.Item1.Add(match.Groups[index].ToString());
          }
          return --state.Item4 != 0;
        }), true);
        if (state1.Item1.Count == 0)
          return new string[1]{ input };
        state1.Item1.Add(input.Substring(state1.Item2, input.Length - state1.Item2));
      }
      else
      {
        state1.Item2 = input.Length;
        regex.Run<(List<string>, int, string, int)>(input, startat, ref state1, (MatchCallback<(List<string>, int, string, int)>) ((ref (List<string> results, int prevat, string input, int count) state, System.Text.RegularExpressions.Match match) =>
        {
          state.Item1.Add(state.Item3.Substring(match.Index + match.Length, state.Item2 - match.Index - match.Length));
          state.Item2 = match.Index;
          for (int index = 1; index < match.Groups.Count; ++index)
          {
            if (match.IsMatched(index))
              state.Item1.Add(match.Groups[index].ToString());
          }
          return --state.Item4 != 0;
        }), true);
        if (state1.Item1.Count == 0)
          return new string[1]{ input };
        state1.Item1.Add(input.Substring(0, state1.Item2));
        state1.Item1.Reverse(0, state1.Item1.Count);
      }
      return state1.Item1.ToArray();
    }

    /// <summary>Gets the time-out interval of the current instance.</summary>
    /// <returns>The maximum time interval that can elapse in a pattern-matching operation before a <see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /> is thrown, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> if time-outs are disabled.</returns>
    public TimeSpan MatchTimeout => this.internalMatchTimeout;

    private static TimeSpan InitDefaultMatchTimeout()
    {
      object data = AppDomain.CurrentDomain.GetData("REGEX_DEFAULT_MATCH_TIMEOUT");
      if (data == null)
        return Regex.InfiniteMatchTimeout;
      if (!(data is TimeSpan timeSpan))
        throw new InvalidCastException(SR.Format(SR.IllegalDefaultRegexMatchTimeoutInAppDomain, (object) "REGEX_DEFAULT_MATCH_TIMEOUT", data));
      try
      {
        Regex.ValidateMatchTimeout(timeSpan);
      }
      catch (ArgumentOutOfRangeException ex)
      {
        throw new ArgumentOutOfRangeException(SR.Format(SR.IllegalDefaultRegexMatchTimeoutInAppDomain, (object) "REGEX_DEFAULT_MATCH_TIMEOUT", (object) timeSpan));
      }
      return timeSpan;
    }
  }
}
